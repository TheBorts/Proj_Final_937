#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <vector>

#include "clas.h"
#include "physics.h"
#include "shaders.h"

// Writer class to handle writing OBJ and MTL files
class writer {
    public:
        std::string objPath;
        std::string mtlPath;
        std::ofstream fileMTL;
        std::ofstream fileOBJ;
        
        writer(const std::string& filenameOBJ){
            objPath = filenameOBJ;
            fileOBJ.open(filenameOBJ);
            if (!fileOBJ.is_open()) {
                std::cerr << "Error opening file for writing: " << filenameOBJ << std::endl;
                return;
            }
        }

        writer(const std::string& filenameOBJ, const std::string& filenameMTL) {
            objPath = filenameOBJ;
            mtlPath = filenameMTL;
        }

        ~writer() {
            if (fileOBJ.is_open()) {
                fileOBJ.close();
            }
            if (fileMTL.is_open()) {
                fileMTL.close();
            }
        }

        void setPaths(const std::string& filenameOBJ, const std::string& filenameMTL) {
            objPath = filenameOBJ;
            mtlPath = filenameMTL;
        }

        void writeMTL(const world& myWorld) {
            fileMTL.open(mtlPath);
            if (!fileMTL.is_open()) {
                std::cerr << "File not open for writing: " << mtlPath << std::endl;
                return;
            }

            
            fileMTL << "# MTL fileMTL generated by writer\n";
            for (int i = 0; i < myWorld.num_tr; i++) {
                AABB* tr = myWorld.trees[i];
                fileMTL << "newmtl " << tr->obj->m->mod->mat.name << "\n";
                fileMTL << "Ka " << tr->obj->m->mod->mat.ambient[0] << " "
                << tr->obj->m->mod->mat.ambient[1] << " "
                << tr->obj->m->mod->mat.ambient[2] << "\n";
                fileMTL << "Kd " << tr->obj->m->mod->mat.diffuse[0] << " "
                << tr->obj->m->mod->mat.diffuse[1] << " "
                << tr->obj->m->mod->mat.diffuse[2] << "\n";
                fileMTL << "Ks " << tr->obj->m->mod->mat.specular[0] << " "
                << tr->obj->m->mod->mat.specular[1] << " "
                << tr->obj->m->mod->mat.specular[2] << "\n";
                fileMTL << "Ns " << tr->obj->m->mod->mat.shininess << "\n";
                if (!tr->obj->m->mod->path_texture.empty()) {
                    fileMTL << "map_Kd " << tr->obj->m->mod->path_texture << "\n";
                }
                fileMTL << "\n"; // Add a newline for readability
            }
            fileMTL.flush();
            if (fileMTL.fail()) {
                std::cerr << "Error writing to file: " << mtlPath << std::endl;
            }

            std::cout << "Writing MTL file: " << mtlPath << std::endl;          
            
            fileMTL.close();

            if (std::filesystem::file_size(mtlPath) == 0) {
                std::cerr << "Warning: File was created but is empty!" << std::endl;
            } else {
                std::cout << "Successfully wrote MTL file with " 
                        << std::filesystem::file_size(mtlPath) 
                        << " bytes to " << mtlPath << std::endl;
            }

        }

        void writeOBJ(const world& myWorld) {
            fileOBJ.open(objPath);
            if (!fileOBJ.is_open()) {
                std::cerr << "FileOBJ not open for writing: " << objPath << std::endl;
                return;
            }

            fileOBJ << "mtllib " << mtlPath << "\n";
            for (int i = 0; i < myWorld.num_tr; i++) {
                AABB* tr = myWorld.trees[i];
                fileOBJ << "o " << tr->obj->m->mod->mod_name << "\n";
                fileOBJ << "usemtl " << tr->obj->m->mod->mat.name << "\n";
                for (size_t j = 0; j < tr->obj->position.size(); j++) {
                    fileOBJ << "v " << tr->obj->position[j].x << " " << tr->obj->position[j].y << " " << tr->obj->position[j].z << "\n";
                }
                for (size_t j = 0; j < tr->obj->m->mod->num_vertices; j++) {
                    fileOBJ << "vn " << tr->obj->m->proper_normals[j].x << " "
                         << tr->obj->m->proper_normals[j].y << " "
                         << tr->obj->m->proper_normals[j].z << "\n";
                }
                for (int j = 0; j < tr->obj->m->mod->num_textures; j++) {
                    fileOBJ << "vt " << tr->obj->m->mod->textures[j].u << " "
                         << tr->obj->m->mod->textures[j].v << "\n";
                }
                for (long long j = 0; j < tr->obj->m->mod->num_faces; j++) {
                    face& f = tr->obj->m->mod->faces[j];
                    fileOBJ << "f";
                    for (long long k = 0; k < f.num_vertex; k++) {
                        fileOBJ << " ";

                        if (tr->obj->m->mod->num_textures == 0) {
                            fileOBJ << " " << f.vertices[k] << "//" << f.normals[k];
                        } else {
                            fileOBJ << " " << f.vertices[k] << "/" << f.textures[k] << "/" << f.normals[k];
                        }
                    }
                    fileOBJ << "\n";
                }
            }
            fileOBJ.close();
        }
};
